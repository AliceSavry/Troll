import { useEffect, useRef, useCallback } from 'react';

// Constants
const CANVAS_WIDTH = 1080;
const CANVAS_HEIGHT = 1920;
const VIRTUAL_WIDTH = 540;
const VIRTUAL_HEIGHT = 960;
const SCALE = CANVAS_WIDTH / VIRTUAL_WIDTH;
const TOTAL_LEVELS = 150;

// Theme definitions with enhanced colors
const THEMES = {
  neonCity: {
    name: 'NEON CITY',
    bg1: '#0a0a1a', bg2: '#1a0a2a',
    platform: '#00f2ff', platformGlow: '#00f2ff',
    trap: '#ff2d55', trapGlow: '#ff2d55',
    player: '#ff2d55', exit: '#ffd700',
    particle: '#00f2ff', gridColor: 'rgba(0, 242, 255, 0.05)',
    ambient: ['#ff2d55', '#00f2ff', '#ffd700'],
    bgParticle: '#00f2ff'
  },
  lavaHell: {
    name: 'LAVA HELL',
    bg1: '#1a0500', bg2: '#2a0a00',
    platform: '#ff6600', platformGlow: '#ff3300',
    trap: '#ff0000', trapGlow: '#ff0000',
    player: '#ffcc00', exit: '#00ff00',
    particle: '#ff6600', gridColor: 'rgba(255, 102, 0, 0.05)',
    ambient: ['#ff0000', '#ff6600', '#ffcc00'],
    bgParticle: '#ff4400'
  },
  iceWorld: {
    name: 'ICE WORLD',
    bg1: '#0a1a2a', bg2: '#0a2a3a',
    platform: '#88ddff', platformGlow: '#00ccff',
    trap: '#ff88aa', trapGlow: '#ff4477',
    player: '#ffffff', exit: '#ffff00',
    particle: '#aaeeff', gridColor: 'rgba(136, 221, 255, 0.05)',
    ambient: ['#88ddff', '#ffffff', '#aaeeff'],
    bgParticle: '#aaddff'
  },
  toxicSwamp: {
    name: 'TOXIC SWAMP',
    bg1: '#0a1a0a', bg2: '#1a2a0a',
    platform: '#44ff44', platformGlow: '#00ff00',
    trap: '#aa00ff', trapGlow: '#ff00ff',
    player: '#00ffaa', exit: '#ffff00',
    particle: '#88ff88', gridColor: 'rgba(68, 255, 68, 0.05)',
    ambient: ['#44ff44', '#00ffaa', '#aaff00'],
    bgParticle: '#66ff66'
  },
  darkVoid: {
    name: 'DARK VOID',
    bg1: '#050505', bg2: '#0a0a0a',
    platform: '#8844ff', platformGlow: '#aa66ff',
    trap: '#ff0044', trapGlow: '#ff0088',
    player: '#ff44ff', exit: '#00ffff',
    particle: '#aa88ff', gridColor: 'rgba(136, 68, 255, 0.03)',
    ambient: ['#8844ff', '#ff44ff', '#4488ff'],
    bgParticle: '#8866ff'
  },
  sunsetDesert: {
    name: 'SUNSET DESERT',
    bg1: '#2a1a0a', bg2: '#3a2010',
    platform: '#ffaa44', platformGlow: '#ff8800',
    trap: '#ff4444', trapGlow: '#ff0000',
    player: '#ff6644', exit: '#44ff88',
    particle: '#ffcc88', gridColor: 'rgba(255, 170, 68, 0.05)',
    ambient: ['#ffaa44', '#ff6644', '#ffcc00'],
    bgParticle: '#ffbb66'
  },
  deepOcean: {
    name: 'DEEP OCEAN',
    bg1: '#001122', bg2: '#002244',
    platform: '#0088ff', platformGlow: '#0066cc',
    trap: '#ff4488', trapGlow: '#ff0066',
    player: '#00ffcc', exit: '#ffff44',
    particle: '#44aaff', gridColor: 'rgba(0, 136, 255, 0.05)',
    ambient: ['#0088ff', '#00ffcc', '#44aaff'],
    bgParticle: '#3399ff'
  },
  crystalCave: {
    name: 'CRYSTAL CAVE',
    bg1: '#1a0a2a', bg2: '#2a1040',
    platform: '#ff88ff', platformGlow: '#ff44ff',
    trap: '#44ffff', trapGlow: '#00ffff',
    player: '#ffaaff', exit: '#aaff44',
    particle: '#ffccff', gridColor: 'rgba(255, 136, 255, 0.05)',
    ambient: ['#ff88ff', '#ffaaff', '#ff44aa'],
    bgParticle: '#ff99ff'
  },
  stormyNight: {
    name: 'STORMY NIGHT',
    bg1: '#0a0a15', bg2: '#151525',
    platform: '#6688aa', platformGlow: '#4466aa',
    trap: '#ffff00', trapGlow: '#ffcc00',
    player: '#aaccff', exit: '#ff8844',
    particle: '#88aacc', gridColor: 'rgba(102, 136, 170, 0.05)',
    ambient: ['#6688aa', '#aaccff', '#ffffff'],
    bgParticle: '#7799bb'
  },
  techMatrix: {
    name: 'TECH MATRIX',
    bg1: '#000a00', bg2: '#001500',
    platform: '#00ff00', platformGlow: '#00cc00',
    trap: '#ff0000', trapGlow: '#cc0000',
    player: '#00ff88', exit: '#ffffff',
    particle: '#44ff44', gridColor: 'rgba(0, 255, 0, 0.08)',
    ambient: ['#00ff00', '#00ff88', '#88ff00'],
    bgParticle: '#33ff33'
  },
  candyLand: {
    name: 'CANDY LAND',
    bg1: '#2a1020', bg2: '#3a1530',
    platform: '#ff66aa', platformGlow: '#ff4488',
    trap: '#44ddff', trapGlow: '#00ccff',
    player: '#ffaacc', exit: '#aaff66',
    particle: '#ffccdd', gridColor: 'rgba(255, 102, 170, 0.05)',
    ambient: ['#ff66aa', '#ffaacc', '#ff88bb'],
    bgParticle: '#ff77bb'
  },
  bloodMoon: {
    name: 'BLOOD MOON',
    bg1: '#150505', bg2: '#200808',
    platform: '#cc3333', platformGlow: '#ff4444',
    trap: '#ff0000', trapGlow: '#ff0000',
    player: '#ff6666', exit: '#ffcc00',
    particle: '#ff5555', gridColor: 'rgba(255, 50, 50, 0.05)',
    ambient: ['#ff3333', '#ff6666', '#cc0000'],
    bgParticle: '#ff4444'
  },
  electricStorm: {
    name: 'ELECTRIC STORM',
    bg1: '#0a0a20', bg2: '#151535',
    platform: '#ffff00', platformGlow: '#ffff88',
    trap: '#ff00ff', trapGlow: '#ff44ff',
    player: '#ffffaa', exit: '#00ffff',
    particle: '#ffff44', gridColor: 'rgba(255, 255, 0, 0.05)',
    ambient: ['#ffff00', '#ffff88', '#ffcc00'],
    bgParticle: '#ffff55'
  },
  shadowRealm: {
    name: 'SHADOW REALM',
    bg1: '#020202', bg2: '#080808',
    platform: '#444466', platformGlow: '#666688',
    trap: '#ff2222', trapGlow: '#ff0000',
    player: '#aaaacc', exit: '#ffaa00',
    particle: '#555577', gridColor: 'rgba(68, 68, 102, 0.03)',
    ambient: ['#444466', '#666688', '#333355'],
    bgParticle: '#555577'
  },
  cosmicDust: {
    name: 'COSMIC DUST',
    bg1: '#0a0515', bg2: '#150a25',
    platform: '#ff88cc', platformGlow: '#ff66aa',
    trap: '#00ff88', trapGlow: '#00ffaa',
    player: '#ffaadd', exit: '#88ffff',
    particle: '#ffbbee', gridColor: 'rgba(255, 136, 204, 0.05)',
    ambient: ['#ff88cc', '#cc66ff', '#88aaff'],
    bgParticle: '#ff99dd'
  }
};

const THEME_ORDER = [
  'neonCity', 'lavaHell', 'iceWorld', 'toxicSwamp', 'darkVoid',
  'sunsetDesert', 'deepOcean', 'crystalCave', 'stormyNight', 'techMatrix',
  'candyLand', 'bloodMoon', 'electricStorm', 'shadowRealm', 'cosmicDust'
];

interface Theme {
  name: string;
  bg1: string;
  bg2: string;
  platform: string;
  platformGlow: string;
  trap: string;
  trapGlow: string;
  player: string;
  exit: string;
  particle: string;
  gridColor: string;
  ambient: string[];
  bgParticle: string;
}

function getThemeForLevel(level: number): Theme {
  const themeIndex = Math.floor((level - 1) / 10) % THEME_ORDER.length;
  return THEMES[THEME_ORDER[themeIndex] as keyof typeof THEMES];
}

// Audio Engine
const createAudioEngine = () => {
  let ctx: AudioContext | null = null;
  
  const init = () => {
    if (!ctx) ctx = new (window.AudioContext || (window as any).webkitAudioContext)();
  };
  
  const play = (type: string) => {
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    const now = ctx.currentTime;
    
    switch(type) {
      case 'jump':
        osc.type = 'sine';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(700, now + 0.08);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now);
        osc.stop(now + 0.12);
        break;
      case 'death':
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(250, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.35);
        gain.gain.setValueAtTime(0.18, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.35);
        osc.start(now);
        osc.stop(now + 0.35);
        break;
      case 'win':
        osc.type = 'sine';
        osc.frequency.setValueAtTime(523, now);
        gain.gain.setValueAtTime(0.12, now);
        osc.start(now);
        setTimeout(() => {
          if (ctx) osc.frequency.setValueAtTime(659, ctx.currentTime);
        }, 80);
        setTimeout(() => {
          if (ctx) {
            osc.frequency.setValueAtTime(784, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.15);
          }
        }, 160);
        osc.stop(now + 0.4);
        break;
      case 'trap':
        osc.type = 'square';
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.setValueAtTime(180, now + 0.04);
        gain.gain.setValueAtTime(0.08, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.08);
        osc.start(now);
        osc.stop(now + 0.08);
        break;
      case 'combo':
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(880, now);
        osc.frequency.exponentialRampToValueAtTime(1320, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
        break;
      case 'nearMiss':
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
        gain.gain.setValueAtTime(0.05, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc.start(now);
        osc.stop(now + 0.08);
        break;
    }
  };
  
  return { init, play };
};

// Particle class
class Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  life: number;
  color: string;
  size: number;
  rotation: number;
  rotationSpeed: number;
  type: string;
  
  constructor(x: number, y: number, color: string, speed = 1, size: number | null = null, type = 'normal') {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 14 * speed;
    this.vy = (Math.random() - 0.5) * 14 * speed - 3;
    this.life = 1.0;
    this.color = color;
    this.size = size || Math.random() * 10 + 4;
    this.rotation = Math.random() * Math.PI * 2;
    this.rotationSpeed = (Math.random() - 0.5) * 0.4;
    this.type = type;
  }
  
  update(dt: number) {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.6;
    this.life -= dt * (this.type === 'trail' ? 4 : 2);
    this.rotation += this.rotationSpeed;
  }
  
  draw(ctx: CanvasRenderingContext2D) {
    ctx.save();
    ctx.globalAlpha = this.life * 0.85;
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.shadowBlur = 20;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    
    if (this.type === 'star') {
      this.drawStar(ctx, 0, 0, 5, this.size, this.size / 2);
    } else if (this.type === 'circle') {
      ctx.beginPath();
      ctx.arc(0, 0, this.size, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
    }
    ctx.restore();
  }
  
  drawStar(ctx: CanvasRenderingContext2D, cx: number, cy: number, spikes: number, outerRadius: number, innerRadius: number) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    const step = Math.PI / spikes;
    
    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    
    for (let i = 0; i < spikes; i++) {
      x = cx + Math.cos(rot) * outerRadius;
      y = cy + Math.sin(rot) * outerRadius;
      ctx.lineTo(x, y);
      rot += step;
      
      x = cx + Math.cos(rot) * innerRadius;
      y = cy + Math.sin(rot) * innerRadius;
      ctx.lineTo(x, y);
      rot += step;
    }
    
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fill();
  }
}

// Ambient Particle
class AmbientParticle {
  x: number;
  y: number;
  size: number;
  speed: number;
  color: string;
  alpha: number;
  wobble: number;
  wobbleSpeed: number;
  
  constructor(theme: Theme, initial = true) {
    this.x = 0;
    this.y = 0;
    this.size = 0;
    this.speed = 0;
    this.color = '';
    this.alpha = 0;
    this.wobble = 0;
    this.wobbleSpeed = 0;
    this.reset(theme, initial);
  }
  
  reset(theme: Theme, initial = false) {
    this.x = Math.random() * VIRTUAL_WIDTH;
    this.y = initial ? Math.random() * VIRTUAL_HEIGHT : -20;
    this.size = Math.random() * 4 + 1;
    this.speed = Math.random() * 0.7 + 0.3;
    this.color = theme.ambient[Math.floor(Math.random() * theme.ambient.length)];
    this.alpha = Math.random() * 0.4 + 0.1;
    this.wobble = Math.random() * Math.PI * 2;
    this.wobbleSpeed = Math.random() * 0.03 + 0.01;
  }
  
  update(_dt: number, theme: Theme) {
    this.y += this.speed;
    this.wobble += this.wobbleSpeed;
    this.x += Math.sin(this.wobble) * 0.4;
    if (this.y > VIRTUAL_HEIGHT + 20) this.reset(theme);
  }
  
  draw(ctx: CanvasRenderingContext2D) {
    ctx.globalAlpha = this.alpha;
    ctx.fillStyle = this.color;
    ctx.shadowBlur = 8;
    ctx.shadowColor = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
  }
}

// Platform interface
interface Platform {
  x: number;
  y: number;
  w: number;
  h: number;
  type: string;
  originalX?: number;
  originalY?: number;
  shakeTime?: number;
  falling?: boolean;
  startX?: number;
  speed?: number;
  range?: number;
  offset?: number;
  action?: (p: Player, t: Platform) => void;
}

// Trap interface
interface Trap {
  x: number;
  y: number;
  w: number;
  h: number;
  triggered?: boolean;
  triggerX?: number;
  triggerY?: number;
  speed?: number;
  warningShown?: boolean;
  targetY?: number;
  direction?: number;
  oscillate?: boolean;
  oscillateSpeed?: number;
  oscillateRange?: number;
  startX?: number;
  startY?: number;
  delay?: number;
  active?: boolean;
  action?: (p: Player, t: Trap, time: number) => void;
}

// Player interface
interface Player {
  x: number;
  y: number;
  w: number;
  h: number;
  vx: number;
  vy: number;
  speed: number;
  jumpForce: number;
  grounded: boolean;
  scaleX: number;
  scaleY: number;
  rotation: number;
  eyeOffset: number;
  coyoteTime: number;
  jumpBuffer: number;
}

// Ghost interface
interface Ghost {
  x: number;
  y: number;
  life: number;
  scaleX: number;
  scaleY: number;
}

// Level class
class Level {
  id: number;
  theme: Theme;
  platforms: Platform[];
  traps: Trap[];
  movingPlatforms: Platform[];
  exit: { x: number; y: number; w: number; h: number };
  spawn: { x: number; y: number };
  
  constructor(id: number) {
    this.id = id;
    this.theme = getThemeForLevel(id);
    this.platforms = [];
    this.traps = [];
    this.movingPlatforms = [];
    this.exit = { x: 460, y: 100, w: 50, h: 80 };
    this.spawn = { x: 60, y: 800 };
    this.generate();
  }
  
  generate() {
    // Progressive difficulty phases
    // 1-25: Tutorial (no traps, very easy)
    // 26-50: Easy (few slow traps)
    // 51-80: Medium (more traps, faster)
    // 81-120: Hard (complex patterns, fast traps)
    // 121-150: Extreme (maximum challenge)
    
    let phase: number;
    if (this.id <= 25) phase = 0;
    else if (this.id <= 50) phase = 1;
    else if (this.id <= 80) phase = 2;
    else if (this.id <= 120) phase = 3;
    else phase = 4;
    
    const difficulty = Math.max(0, (this.id - 25) / (TOTAL_LEVELS - 25));
    const pattern = this.id <= 25 ? (this.id - 1) % 6 : (this.id - 1) % 12;
    
    // Starting platform
    this.platforms.push({ x: 0, y: 870, w: 250, h: 90, type: 'ground' });
    
    // Generate level based on pattern
    switch(pattern) {
      case 0: this.patternEasyStairs(difficulty, phase); break;
      case 1: this.patternSimpleZigzag(difficulty, phase); break;
      case 2: this.patternWidePlatforms(difficulty, phase); break;
      case 3: this.patternGentleClimb(difficulty, phase); break;
      case 4: this.patternSafeSpiral(difficulty, phase); break;
      case 5: this.patternAlternating(difficulty, phase); break;
      case 6: this.patternTowerClimb(difficulty, phase); break;
      case 7: this.patternMixedPath(difficulty, phase); break;
      case 8: this.patternNarrowGaps(difficulty, phase); break;
      case 9: this.patternFloatingIslands(difficulty, phase); break;
      case 10: this.patternZigzagTight(difficulty, phase); break;
      case 11: this.patternVerticalChallenge(difficulty, phase); break;
    }
    
    // Add traps only after tutorial
    if (phase >= 1) {
      this.addTraps(difficulty, phase);
    }
    
    // Add moving platforms for medium+ difficulty
    if (phase >= 2 && Math.random() < 0.3 + difficulty * 0.3) {
      this.addMovingPlatform(difficulty, phase);
    }
  }
  
  patternEasyStairs(_diff: number, phase: number) {
    const steps = 5 + phase;
    const platWidth = 160 - phase * 12;
    
    for (let i = 0; i < steps; i++) {
      const x = i % 2 === 0 ? 30 : VIRTUAL_WIDTH - platWidth - 30;
      const y = 750 - i * 115;
      this.platforms.push({ x, y, w: platWidth, h: 30, type: 'normal' });
    }
    
    const lastX = (steps - 1) % 2 === 0 ? 30 : VIRTUAL_WIDTH - platWidth - 30;
    this.exit.x = lastX + platWidth/2 - 25;
    this.exit.y = 750 - (steps - 1) * 115 - 80;
  }
  
  patternSimpleZigzag(_diff: number, phase: number) {
    const platWidth = 150 - phase * 15;
    const steps = 6 + Math.floor(phase / 2);
    
    for (let i = 0; i < steps; i++) {
      const x = i % 2 === 0 ? 40 : VIRTUAL_WIDTH - platWidth - 40;
      const y = 730 - i * 105;
      this.platforms.push({ x, y, w: platWidth, h: 28, type: 'normal' });
    }
    
    const lastX = (steps - 1) % 2 === 0 ? 40 : VIRTUAL_WIDTH - platWidth - 40;
    this.exit.x = lastX + platWidth/2 - 25;
    this.exit.y = 730 - (steps - 1) * 105 - 80;
  }
  
  patternWidePlatforms(_diff: number, phase: number) {
    const steps = 5 + phase;
    for (let i = 0; i < steps; i++) {
      const width = VIRTUAL_WIDTH - 80 - i * (30 + phase * 5);
      const x = 40 + i * (15 + phase * 2.5);
      this.platforms.push({
        x: Math.max(30, x), 
        y: 750 - i * 130, 
        w: Math.max(80, width), 
        h: 32, 
        type: 'normal'
      });
    }
    
    this.exit.x = VIRTUAL_WIDTH/2 - 25;
    this.exit.y = 750 - (steps - 1) * 130 - 80;
  }
  
  patternGentleClimb(_diff: number, phase: number) {
    const platWidth = 120 - phase * 8;
    let x = 50;
    let direction = 1;
    const steps = 6 + phase;
    
    for (let i = 0; i < steps; i++) {
      this.platforms.push({
        x, y: 750 - i * 110, w: platWidth, h: 26, type: 'normal'
      });
      
      x += direction * (90 + phase * 10);
      if (x > VIRTUAL_WIDTH - platWidth - 50 || x < 50) {
        direction *= -1;
        x += direction * (90 + phase * 10);
      }
    }
    
    this.exit.x = Math.max(30, Math.min(VIRTUAL_WIDTH - 75, x + platWidth/2 - 25));
    this.exit.y = 750 - (steps - 1) * 110 - 80;
  }
  
  patternSafeSpiral(_diff: number, phase: number) {
    const steps = 7 + phase;
    const platWidth = 120 - phase * 5;
    
    for (let i = 0; i < steps; i++) {
      const angle = (i / steps) * Math.PI * 1.5;
      const radius = 100 + phase * 15;
      const x = VIRTUAL_WIDTH/2 + Math.cos(angle) * radius - platWidth/2;
      const y = 780 - i * 95;
      this.platforms.push({ 
        x: Math.max(20, Math.min(VIRTUAL_WIDTH - platWidth - 20, x)), 
        y, 
        w: platWidth, 
        h: 26, 
        type: 'normal' 
      });
    }
    
    this.exit.x = VIRTUAL_WIDTH/2 - 25;
    this.exit.y = 780 - (steps - 1) * 95 - 80;
  }
  
  patternAlternating(_diff: number, phase: number) {
    const platWidth = 130 - phase * 10;
    const steps = 6 + phase;
    
    for (let i = 0; i < steps; i++) {
      const x = i % 2 === 0 ? 35 : VIRTUAL_WIDTH - platWidth - 35;
      const y = 740 - i * 110;
      this.platforms.push({ x, y, w: platWidth, h: 28, type: 'normal' });
    }
    
    const lastX = (steps - 1) % 2 === 0 ? 35 : VIRTUAL_WIDTH - platWidth - 35;
    this.exit.x = lastX + platWidth/2 - 25;
    this.exit.y = 740 - (steps - 1) * 110 - 80;
  }
  
  patternTowerClimb(_diff: number, phase: number) {
    const centerX = VIRTUAL_WIDTH/2 - 65;
    const platWidth = 130 - phase * 8;
    const steps = 7 + phase;
    
    for (let i = 0; i < steps; i++) {
      const offset = Math.sin(i * 0.8) * (50 + phase * 20);
      const x = Math.max(20, Math.min(VIRTUAL_WIDTH - platWidth - 20, centerX + offset));
      this.platforms.push({
        x, y: 780 - i * 90, w: platWidth, h: 26, type: 'normal'
      });
    }
    
    this.exit.x = centerX + 35;
    this.exit.y = 780 - (steps - 1) * 90 - 80;
  }
  
  patternMixedPath(_diff: number, phase: number) {
    const platWidth = 120;
    
    this.platforms.push({ x: 30, y: 720, w: platWidth, h: 26, type: 'normal' });
    this.platforms.push({ x: VIRTUAL_WIDTH - platWidth - 30, y: 600, w: platWidth, h: 26, type: 'normal' });
    this.platforms.push({ x: 30, y: 480, w: platWidth, h: 26, type: 'normal' });
    this.platforms.push({ x: VIRTUAL_WIDTH - platWidth - 30, y: 360, w: platWidth, h: 26, type: 'normal' });
    this.platforms.push({ x: VIRTUAL_WIDTH/2 - platWidth/2, y: 240, w: platWidth, h: 26, type: 'normal' });
    
    if (phase >= 2) {
      this.platforms.push({ x: VIRTUAL_WIDTH/2 - 50, y: 540, w: 100, h: 22, type: 'normal' });
      this.platforms.push({ x: VIRTUAL_WIDTH/2 - 50, y: 420, w: 100, h: 22, type: 'normal' });
    }
    
    this.exit.x = VIRTUAL_WIDTH/2 - 25;
    this.exit.y = 160;
  }
  
  patternNarrowGaps(_diff: number, phase: number) {
    const platWidth = 100 - phase * 5;
    // gap size increases with phase
    const steps = 6 + phase;
    
    for (let i = 0; i < steps; i++) {
      const x = i % 3 === 0 ? 40 : (i % 3 === 1 ? VIRTUAL_WIDTH/2 - platWidth/2 : VIRTUAL_WIDTH - platWidth - 40);
      const y = 750 - i * 100;
      this.platforms.push({ x, y, w: platWidth, h: 24, type: 'normal' });
    }
    
    const lastX = ((steps - 1) % 3 === 0) ? 40 : ((steps - 1) % 3 === 1 ? VIRTUAL_WIDTH/2 - platWidth/2 : VIRTUAL_WIDTH - platWidth - 40);
    this.exit.x = lastX + platWidth/2 - 25;
    this.exit.y = 750 - (steps - 1) * 100 - 80;
  }
  
  patternFloatingIslands(_diff: number, phase: number) {
    const platWidth = 90 - phase * 3;
    const steps = 8 + phase;
    
    for (let i = 0; i < steps; i++) {
      const x = 50 + Math.sin(i * 1.2) * (VIRTUAL_WIDTH/2 - platWidth - 50);
      const y = 780 - i * 85;
      this.platforms.push({ 
        x: VIRTUAL_WIDTH/2 - platWidth/2 + x - VIRTUAL_WIDTH/2 + platWidth/2,
        y, 
        w: platWidth, 
        h: 24, 
        type: 'normal' 
      });
    }
    
    this.exit.x = VIRTUAL_WIDTH/2 - 25;
    this.exit.y = 780 - (steps - 1) * 85 - 80;
  }
  
  patternZigzagTight(_diff: number, phase: number) {
    const platWidth = 110 - phase * 8;
    const steps = 7 + phase;
    
    for (let i = 0; i < steps; i++) {
      const x = i % 2 === 0 ? 25 : VIRTUAL_WIDTH - platWidth - 25;
      const y = 760 - i * 95;
      this.platforms.push({ x, y, w: platWidth, h: 24, type: 'normal' });
    }
    
    const lastX = (steps - 1) % 2 === 0 ? 25 : VIRTUAL_WIDTH - platWidth - 25;
    this.exit.x = lastX + platWidth/2 - 25;
    this.exit.y = 760 - (steps - 1) * 95 - 80;
  }
  
  patternVerticalChallenge(_diff: number, phase: number) {
    const platWidth = 100;
    const steps = 8 + phase;
    
    // Center column with slight offsets
    for (let i = 0; i < steps; i++) {
      const offset = (i % 2 === 0 ? -1 : 1) * (40 + phase * 10);
      const x = VIRTUAL_WIDTH/2 - platWidth/2 + offset;
      const y = 770 - i * 90;
      this.platforms.push({ x, y, w: platWidth, h: 24, type: 'normal' });
    }
    
    this.exit.x = VIRTUAL_WIDTH/2 - 25;
    this.exit.y = 770 - (steps - 1) * 90 - 80;
  }
  
  addMovingPlatform(diff: number, phase: number) {
    const y = 400 + Math.random() * 200;
    const platWidth = 100 - phase * 5;
    const speed = 1.5 + diff * 2;
    const range = 80 + phase * 20;
    
    this.movingPlatforms.push({
      x: VIRTUAL_WIDTH/2 - platWidth/2,
      y,
      w: platWidth,
      h: 24,
      type: 'moving',
      startX: VIRTUAL_WIDTH/2 - platWidth/2,
      speed,
      range,
      offset: Math.random() * Math.PI * 2
    });
  }
  
  addTraps(diff: number, phase: number) {
    let trapCount = 0;
    
    if (phase === 1) {
      trapCount = Math.random() < 0.3 + diff * 0.2 ? 1 : 0;
    } else if (phase === 2) {
      trapCount = 1;
      if (Math.random() < 0.3 + diff * 0.2) trapCount++;
    } else if (phase === 3) {
      trapCount = 2;
      if (Math.random() < 0.4 + diff * 0.2) trapCount++;
    } else if (phase === 4) {
      trapCount = 3;
      if (Math.random() < 0.5) trapCount++;
    }
    
    for (let i = 0; i < trapCount; i++) {
      this.addSingleTrap(diff, phase, i);
    }
  }
  
  addSingleTrap(diff: number, phase: number, index: number) {
    let trapTypes: number[];
    if (phase === 1) {
      trapTypes = [1];
    } else if (phase === 2) {
      trapTypes = [0, 1, 2];
    } else if (phase === 3) {
      trapTypes = [0, 1, 2, 3, 4];
    } else {
      trapTypes = [0, 1, 2, 3, 4, 5];
    }
    
    const trapType = trapTypes[Math.floor(Math.random() * trapTypes.length)];
    
    let baseSpeed: number;
    if (phase === 1) baseSpeed = 1.8;
    else if (phase === 2) baseSpeed = 2.5;
    else if (phase === 3) baseSpeed = 3.5;
    else baseSpeed = 4.5;
    
    const speed = baseSpeed + diff * 2.5;
    
    switch(trapType) {
      case 0: { // Falling trap
        const fallX = 120 + Math.random() * (VIRTUAL_WIDTH - 240);
        this.traps.push({
          x: fallX,
          y: -180,
          w: 40,
          h: 140,
          triggered: false,
          triggerX: fallX + 20,
          speed: speed,
          action: (p: Player, t: Trap) => {
            if (Math.abs(p.x + 20 - (t.triggerX || 0)) < 90) {
              t.y += t.speed || 0;
            }
            if (t.y > 1000) {
              t.y = -180;
            }
          }
        });
        break;
      }
      case 1: { // Rising trap
        const riseX = 80 + Math.random() * (VIRTUAL_WIDTH - 160);
        const targetY = 350 + Math.random() * 300;
        this.traps.push({
          x: riseX,
          y: VIRTUAL_HEIGHT + 50,
          w: 55,
          h: 90,
          triggered: false,
          triggerX: riseX + 27,
          targetY: targetY,
          speed: speed * 0.7,
          action: (p: Player, t: Trap) => {
            if (p.x > (t.triggerX || 0) - 130 && p.x < (t.triggerX || 0) + 130 && t.y > (t.targetY || 0)) {
              t.y -= t.speed || 0;
            }
          }
        });
        break;
      }
      case 2: { // Side trap
        const fromLeft = index % 2 === 0;
        const sideY = 250 + Math.random() * 450;
        this.traps.push({
          x: fromLeft ? -180 : VIRTUAL_WIDTH + 60,
          y: sideY,
          w: 120,
          h: 30,
          triggered: false,
          triggerY: sideY,
          direction: fromLeft ? 1 : -1,
          speed: speed * 0.6,
          action: (p: Player, t: Trap) => {
            if (Math.abs(p.y - (t.triggerY || 0)) < 180) {
              t.x += (t.direction || 0) * (t.speed || 0);
            }
            const fromLeft = (t.direction || 0) > 0;
            if ((fromLeft && t.x > VIRTUAL_WIDTH + 100) || 
                (!fromLeft && t.x < -200)) {
              t.x = fromLeft ? -180 : VIRTUAL_WIDTH + 60;
            }
          }
        });
        break;
      }
      case 3: { // Oscillating trap
        const oscX = 100 + Math.random() * (VIRTUAL_WIDTH - 200);
        const oscY = 300 + Math.random() * 350;
        this.traps.push({
          x: oscX,
          y: oscY,
          w: 50,
          h: 50,
          oscillate: true,
          oscillateSpeed: 2 + phase * 0.5,
          oscillateRange: 80 + phase * 20,
          startX: oscX,
          startY: oscY,
          action: (_p: Player, t: Trap, time: number) => {
            t.x = (t.startX || 0) + Math.sin(time * (t.oscillateSpeed || 0)) * (t.oscillateRange || 0);
          }
        });
        break;
      }
      case 4: { // Delayed trap (appears after delay)
        const delayX = 150 + Math.random() * (VIRTUAL_WIDTH - 300);
        const delayY = 300 + Math.random() * 300;
        this.traps.push({
          x: delayX,
          y: delayY,
          w: 60,
          h: 60,
          delay: 1.5 + Math.random(),
          active: false,
          action: (_p: Player, t: Trap, time: number) => {
            if (time > (t.delay || 0)) {
              t.active = true;
            }
          }
        });
        break;
      }
      case 5: { // Homing trap (slowly follows player Y)
        const homeX = Math.random() < 0.5 ? 30 : VIRTUAL_WIDTH - 80;
        this.traps.push({
          x: homeX,
          y: 400,
          w: 50,
          h: 50,
          speed: speed * 0.3,
          action: (p: Player, t: Trap) => {
            const dy = p.y - t.y;
            t.y += Math.sign(dy) * Math.min(Math.abs(dy) * 0.02, t.speed || 0);
          }
        });
        break;
      }
    }
    
    // Fake platform trap
    if (phase >= 3 && this.platforms.length > 2 && Math.random() < 0.25) {
      const eligibleIndices = [];
      for (let i = 1; i < this.platforms.length - 1; i++) {
        eligibleIndices.push(i);
      }
      
      if (eligibleIndices.length > 0) {
        const idx = eligibleIndices[Math.floor(Math.random() * eligibleIndices.length)];
        const plat = this.platforms[idx];
        
        plat.type = 'fake';
        plat.originalX = plat.x;
        plat.shakeTime = 0;
        plat.falling = false;
        plat.action = (p: Player, t: Platform) => {
          if (p.x + 40 > t.x && p.x < t.x + t.w && 
              p.y + 50 >= t.y - 5 && p.y + 50 <= t.y + 10) {
            t.shakeTime = (t.shakeTime || 0) + 0.016;
            
            if ((t.shakeTime || 0) > 1.2) {
              t.falling = true;
            } else {
              t.x = (t.originalX || 0) + Math.sin((t.shakeTime || 0) * 50) * 5;
            }
          }
          
          if (t.falling) {
            t.y += 10;
          }
        };
      }
    }
  }
  
  update(player: Player, time: number) {
    this.movingPlatforms.forEach(mp => {
      mp.x = (mp.startX || 0) + Math.sin(time * (mp.speed || 1) + (mp.offset || 0)) * (mp.range || 0);
    });
    
    this.traps.forEach(t => {
      if (t.action) t.action(player, t, time);
    });
    
    this.platforms.forEach(p => {
      if (p.action) p.action(player, p);
    });
  }
}

export function App() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const gameRef = useRef<any>(null);
  
  const initGame = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d')!;
    const audioEngine = createAudioEngine();
    
    const game = {
      state: 'START' as 'START' | 'PLAYING' | 'GAMEOVER',
      levelId: 1,
      deaths: 0,
      totalTime: 0,
      particles: [] as Particle[],
      ambientParticles: [] as AmbientParticle[],
      shake: 0,
      flash: 0,
      flashColor: 'white',
      time: 0,
      ghosts: [] as Ghost[],
      demoMode: false,
      lastInput: Date.now(),
      highScores: [] as { name: string; deaths: number }[],
      combo: 0,
      comboTimer: 0,
      nearMissTimer: 0,
      screenPulse: 0,
      speedLines: [] as { x: number; y: number; speed: number; alpha: number }[],
      level: null as Level | null,
      lastFrame: 0,
      
      player: {
        x: 60, y: 800, w: 40, h: 50,
        vx: 0, vy: 0,
        speed: 7.5,
        jumpForce: -17.5,
        grounded: false,
        scaleX: 1, scaleY: 1,
        rotation: 0,
        eyeOffset: 0,
        coyoteTime: 0,
        jumpBuffer: 0
      } as Player,
      
      input: { left: false, right: false, up: false },
      
      init() {
        this.setupEvents();
        this.loadScores();
        this.resetLevel();
        this.initAmbientParticles();
        this.loop();
      },
      
      initAmbientParticles() {
        this.ambientParticles = [];
        const theme = getThemeForLevel(this.levelId);
        for (let i = 0; i < 40; i++) {
          this.ambientParticles.push(new AmbientParticle(theme));
        }
      },
      
      setupEvents() {
        const handle = (type: string, val: boolean) => {
          audioEngine.init();
          this.lastInput = Date.now();
          if (this.demoMode) this.stopDemo();
          (this.input as any)[type] = val;
        };
        
        window.addEventListener('keydown', (e: KeyboardEvent) => {
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') handle('left', true);
          if (e.code === 'ArrowRight' || e.code === 'KeyD') handle('right', true);
          if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') { 
            e.preventDefault();
            handle('up', true);
          }
          if (e.code === 'Enter' && this.state === 'START') {
            this.start();
          }
          if (e.code === 'KeyR' && this.state === 'GAMEOVER') {
            this.reset();
          }
        });
        
        window.addEventListener('keyup', (e: KeyboardEvent) => {
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') handle('left', false);
          if (e.code === 'ArrowRight' || e.code === 'KeyD') handle('right', false);
          if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') handle('up', false);
        });
        
        canvas.addEventListener('touchstart', (e: TouchEvent) => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.touches[0].clientX - rect.left) / rect.width;
          const y = (e.touches[0].clientY - rect.top) / rect.height;
          
          if (this.state === 'START') {
            this.start();
            return;
          }
          
          if (y < 0.65) {
            handle('up', true);
          } else {
            if (x < 0.35) handle('left', true);
            else if (x > 0.65) handle('right', true);
            else handle('up', true);
          }
        });
        
        canvas.addEventListener('touchend', () => {
          this.input.left = this.input.right = this.input.up = false;
        });
        
        canvas.addEventListener('touchmove', (e: TouchEvent) => {
          e.preventDefault();
        });
        
        canvas.addEventListener('click', () => {
          if (this.state === 'START') {
            this.start();
          }
        });
      },
      
      resetLevel() {
        this.level = new Level(this.levelId);
        this.player.x = this.level.spawn.x;
        this.player.y = this.level.spawn.y;
        this.player.vx = this.player.vy = 0;
        this.player.rotation = 0;
        this.player.coyoteTime = 0;
        this.player.jumpBuffer = 0;
        this.ghosts = [];
        this.initAmbientParticles();
      },
      
      start() {
        this.state = 'PLAYING';
        this.levelId = 1;
        this.deaths = 0;
        this.totalTime = 0;
        this.combo = 0;
        this.comboTimer = 0;
        this.resetLevel();
        this.flash = 0.3;
        this.flashColor = '#00ff00';
      },
      
      die() {
        this.deaths++;
        this.shake = 30;
        this.flash = 0.6;
        this.flashColor = this.level?.theme.trap || '#ff0000';
        audioEngine.play('death');
        this.combo = 0;
        this.comboTimer = 0;
        
        // Death particles
        for (let i = 0; i < 35; i++) {
          this.particles.push(new Particle(
            this.player.x + this.player.w/2,
            this.player.y + this.player.h/2,
            this.level?.theme.player || '#ff0000',
            2,
            null,
            Math.random() < 0.3 ? 'star' : 'normal'
          ));
        }
        
        setTimeout(() => this.resetLevel(), 350);
      },
      
      win() {
        audioEngine.play('win');
        this.flash = 0.5;
        this.flashColor = this.level?.theme.exit || '#ffd700';
        this.screenPulse = 1;
        
        // Combo system
        this.combo++;
        this.comboTimer = 3;
        if (this.combo > 1) {
          audioEngine.play('combo');
        }
        
        // Win particles - more satisfying
        for (let i = 0; i < 50; i++) {
          this.particles.push(new Particle(
            this.level!.exit.x + this.level!.exit.w/2,
            this.level!.exit.y + this.level!.exit.h/2,
            i % 3 === 0 ? this.level!.theme.exit : this.level!.theme.ambient[i % this.level!.theme.ambient.length],
            2.5,
            null,
            i % 4 === 0 ? 'star' : (i % 3 === 0 ? 'circle' : 'normal')
          ));
        }
        
        this.levelId++;
        
        if (this.levelId > TOTAL_LEVELS) {
          setTimeout(() => this.gameOver(), 600);
        } else {
          setTimeout(() => {
            this.resetLevel();
            this.flash = 0.2;
            this.flashColor = '#ffffff';
          }, 400);
        }
      },
      
      gameOver() {
        this.state = 'GAMEOVER';
      },
      
      checkNearMiss(trap: Trap) {
        const margin = 15;
        const nearHitbox = {
          x: trap.x - margin,
          y: trap.y - margin,
          w: trap.w + margin * 2,
          h: trap.h + margin * 2
        };
        
        if (this.checkCollision(this.player, nearHitbox) && !this.checkTrapCollision(this.player, trap)) {
          if (this.nearMissTimer <= 0) {
            this.nearMissTimer = 0.5;
            audioEngine.play('nearMiss');
            
            // Near miss particles
            for (let i = 0; i < 8; i++) {
              this.particles.push(new Particle(
                this.player.x + this.player.w/2,
                this.player.y + this.player.h/2,
                '#ffffff',
                0.8,
                4,
                'circle'
              ));
            }
          }
        }
      },
      
      update(dt: number) {
        this.time += dt;
        this.comboTimer = Math.max(0, this.comboTimer - dt);
        this.nearMissTimer = Math.max(0, this.nearMissTimer - dt);
        this.screenPulse = Math.max(0, this.screenPulse - dt * 3);
        
        if (this.comboTimer <= 0) {
          this.combo = 0;
        }
        
        // Update ambient particles
        const theme = getThemeForLevel(this.levelId);
        this.ambientParticles.forEach(p => p.update(dt, theme));
        
        // Speed lines when moving fast
        if (Math.abs(this.player.vy) > 10) {
          for (let i = 0; i < 2; i++) {
            this.speedLines.push({
              x: Math.random() * VIRTUAL_WIDTH,
              y: this.player.y - 100 + Math.random() * 200,
              speed: Math.abs(this.player.vy) * 2,
              alpha: 0.5
            });
          }
        }
        
        // Update speed lines
        this.speedLines = this.speedLines.filter(line => {
          line.y += line.speed * (this.player.vy > 0 ? -1 : 1);
          line.alpha -= dt * 3;
          return line.alpha > 0;
        });
        
        if (this.state !== 'PLAYING') {
          if (Date.now() - this.lastInput > 10000 && !this.demoMode && this.state === 'START') {
            this.startDemo();
          }
          return;
        }
        
        this.totalTime += dt;
        
        if (this.demoMode) this.updateAI();
        
        // Physics
        this.player.vy += 0.75;
        
        // Terminal velocity
        if (this.player.vy > 16) this.player.vy = 16;
        
        // Input
        if (this.input.left) {
          this.player.vx = -this.player.speed;
          this.player.eyeOffset = -3;
        } else if (this.input.right) {
          this.player.vx = this.player.speed;
          this.player.eyeOffset = 3;
        } else {
          this.player.vx *= 0.82;
          this.player.eyeOffset *= 0.88;
        }
        
        // Apply velocity
        this.player.x += this.player.vx;
        this.player.y += this.player.vy;
        
        // Wall collision
        if (this.player.x < 0) { this.player.x = 0; this.player.vx = 0; }
        if (this.player.x > VIRTUAL_WIDTH - this.player.w) { 
          this.player.x = VIRTUAL_WIDTH - this.player.w; 
          this.player.vx = 0; 
        }
        
        // Squash & Stretch
        this.player.scaleX += (1 - this.player.scaleX) * 0.18;
        this.player.scaleY += (1 - this.player.scaleY) * 0.18;
        
        // Rotation based on velocity
        this.player.rotation += this.player.vx * 0.012;
        this.player.rotation *= 0.93;
        
        // Ghost trail
        if (Math.abs(this.player.vx) > 2.5 || Math.abs(this.player.vy) > 6) {
          this.ghosts.push({ 
            x: this.player.x, 
            y: this.player.y, 
            life: 0.5,
            scaleX: this.player.scaleX,
            scaleY: this.player.scaleY
          });
          if (this.ghosts.length > 8) this.ghosts.shift();
        }
        
        // Update level
        if (this.level) {
          this.level.update(this.player, this.time);
        }
        
        // Platform collision
        const wasGrounded = this.player.grounded;
        this.player.grounded = false;
        
        if (this.level) {
          const allPlatforms = [...this.level.platforms, ...this.level.movingPlatforms];
          
          allPlatforms.forEach(obj => {
            if (obj.y > VIRTUAL_HEIGHT + 100) return;
            if (obj.type === 'fake' && (obj.y || 0) > VIRTUAL_HEIGHT) return;
            
            if (this.checkCollision(this.player, obj)) {
              this.resolveCollision(this.player, obj, wasGrounded);
            }
          });
          
          // Trap collision
          this.level.traps.forEach(trap => {
            if (trap.active === false) return; // Skip inactive delayed traps
            this.checkNearMiss(trap);
            if (this.checkTrapCollision(this.player, trap)) {
              this.die();
            }
          });
        }
        
        // Coyote time
        if (this.player.grounded) {
          this.player.coyoteTime = 0.18;
        } else {
          this.player.coyoteTime -= dt;
        }
        
        // Jump buffer
        if (this.input.up) {
          this.player.jumpBuffer = 0.12;
        } else {
          this.player.jumpBuffer -= dt;
        }
        
        // Jump
        const canJump = this.player.grounded || this.player.coyoteTime > 0;
        const wantsToJump = this.input.up || this.player.jumpBuffer > 0;
        
        if (canJump && wantsToJump && this.player.vy >= 0) {
          this.player.vy = this.player.jumpForce;
          this.player.grounded = false;
          this.player.coyoteTime = 0;
          this.player.jumpBuffer = 0;
          this.player.scaleX = 0.65;
          this.player.scaleY = 1.45;
          audioEngine.play('jump');
          
          // Jump particles
          for (let i = 0; i < 8; i++) {
            this.particles.push(new Particle(
              this.player.x + this.player.w/2,
              this.player.y + this.player.h,
              this.level?.theme.platform || '#00f2ff',
              0.6,
              4,
              'circle'
            ));
          }
        }
        
        // Fall death
        if (this.player.y > VIRTUAL_HEIGHT + 50) {
          this.die();
        }
        
        // Exit check
        if (this.level && this.checkCollision(this.player, this.level.exit)) {
          this.win();
        }
        
        // Update particles
        this.particles = this.particles.filter(p => {
          p.update(dt);
          return p.life > 0;
        });
        
        // Update ghosts
        this.ghosts.forEach(g => g.life -= dt * 3.5);
        this.ghosts = this.ghosts.filter(g => g.life > 0);
        
        // Decay effects
        if (this.shake > 0) this.shake *= 0.88;
        if (this.flash > 0) this.flash -= dt * 3.5;
      },
      
      checkCollision(a: { x: number; y: number; w: number; h: number }, b: { x: number; y: number; w: number; h: number }) {
        return a.x < b.x + b.w && a.x + a.w > b.x &&
               a.y < b.y + b.h && a.y + a.h > b.y;
      },
      
      checkTrapCollision(player: Player, trap: Trap) {
        const marginX = 8;
        const marginY = 8;
        const hitbox = {
          x: trap.x + marginX,
          y: trap.y + marginY,
          w: Math.max(0, trap.w - marginX * 2),
          h: Math.max(0, trap.h - marginY * 2)
        };
        return this.checkCollision(player, hitbox);
      },
      
      resolveCollision(player: Player, obj: Platform, wasGrounded: boolean) {
        const overlapX = Math.min(player.x + player.w - obj.x, obj.x + obj.w - player.x);
        const overlapY = Math.min(player.y + player.h - obj.y, obj.y + obj.h - player.y);
        
        if (overlapX < overlapY) {
          if (player.x < obj.x) {
            player.x -= overlapX;
          } else {
            player.x += overlapX;
          }
          player.vx = 0;
        } else {
          if (player.vy > 0 && player.y < obj.y) {
            player.y = obj.y - player.h;
            player.vy = 0;
            player.grounded = true;
            
            if (!wasGrounded) {
              player.scaleX = 1.35;
              player.scaleY = 0.65;
            }
          } else if (player.vy < 0) {
            player.y = obj.y + obj.h;
            player.vy = 0;
          }
        }
      },
      
      draw() {
        const theme = this.level?.theme || THEMES.neonCity;
        
        ctx.save();
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // Camera shake
        if (this.shake > 0.5) {
          ctx.translate(
            (Math.random() - 0.5) * this.shake * 2,
            (Math.random() - 0.5) * this.shake * 2
          );
        }
        
        // Screen pulse effect
        const pulseScale = 1 + this.screenPulse * 0.02;
        ctx.translate(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
        ctx.scale(pulseScale, pulseScale);
        ctx.translate(-CANVAS_WIDTH / 2, -CANVAS_HEIGHT / 2);
        
        ctx.scale(SCALE, SCALE);
        
        // Background gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, VIRTUAL_HEIGHT);
        gradient.addColorStop(0, theme.bg1);
        gradient.addColorStop(1, theme.bg2);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);
        
        // Animated grid effect
        ctx.strokeStyle = theme.gridColor;
        ctx.lineWidth = 1;
        const gridOffset = (this.time * 40) % 60;
        
        for (let x = 0; x < VIRTUAL_WIDTH; x += 60) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, VIRTUAL_HEIGHT);
          ctx.stroke();
        }
        
        for (let y = gridOffset; y < VIRTUAL_HEIGHT; y += 60) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(VIRTUAL_WIDTH, y);
          ctx.stroke();
        }
        
        // Ambient particles
        this.ambientParticles.forEach(p => p.draw(ctx));
        
        // Speed lines
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 2;
        this.speedLines.forEach(line => {
          ctx.globalAlpha = line.alpha;
          ctx.beginPath();
          ctx.moveTo(line.x, line.y);
          ctx.lineTo(line.x, line.y + 30);
          ctx.stroke();
        });
        ctx.globalAlpha = 1;
        
        if (this.level) {
          // Draw platforms
          ctx.shadowBlur = 25;
          
          [...this.level.platforms, ...this.level.movingPlatforms].forEach(p => {
            if (p.y > VIRTUAL_HEIGHT + 50) return;
            
            const isFake = p.type === 'fake';
            const isMoving = p.type === 'moving';
            const color = isFake ? theme.trap : theme.platform;
            
            ctx.shadowColor = isFake ? theme.trapGlow : theme.platformGlow;
            
            // Platform body with gradient
            const grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
            grad.addColorStop(0, color);
            grad.addColorStop(1, this.adjustColor(color, -40));
            ctx.fillStyle = grad;
            
            this.roundRect(ctx, p.x, p.y, p.w, p.h, 6);
            ctx.fill();
            
            // Top highlight
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(p.x + 6, p.y + 2);
            ctx.lineTo(p.x + p.w - 6, p.y + 2);
            ctx.stroke();
            
            // Moving platform indicator
            if (isMoving) {
              ctx.strokeStyle = 'rgba(255,255,255,0.2)';
              ctx.lineWidth = 1;
              ctx.setLineDash([4, 4]);
              ctx.beginPath();
              ctx.moveTo((p.startX || 0) - (p.range || 0), p.y + p.h/2);
              ctx.lineTo((p.startX || 0) + p.w + (p.range || 0), p.y + p.h/2);
              ctx.stroke();
              ctx.setLineDash([]);
            }
          });
          
          // Draw traps with enhanced visuals
          this.level.traps.forEach(t => {
            if (t.y > VIRTUAL_HEIGHT + 100 || t.y + t.h < -100) return;
            if (t.active === false) return;
            
            ctx.shadowColor = theme.trapGlow;
            ctx.shadowBlur = 30;
            
            // Pulsing glow effect
            const pulse = Math.sin(this.time * 8) * 0.3 + 0.7;
            ctx.globalAlpha = pulse;
            
            // Gradient fill
            const trapGrad = ctx.createLinearGradient(t.x, t.y, t.x, t.y + t.h);
            trapGrad.addColorStop(0, theme.trap);
            trapGrad.addColorStop(0.5, this.adjustColor(theme.trap, 30));
            trapGrad.addColorStop(1, theme.trap);
            ctx.fillStyle = trapGrad;
            
            // Spiky appearance
            ctx.beginPath();
            const spikes = Math.max(2, Math.floor(t.w / 12));
            for (let i = 0; i <= spikes; i++) {
              const x = t.x + (i / spikes) * t.w;
              const y = i % 2 === 0 ? t.y : t.y + 12;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.lineTo(t.x + t.w, t.y + t.h);
            for (let i = spikes; i >= 0; i--) {
              const x = t.x + (i / spikes) * t.w;
              const y = i % 2 === 0 ? t.y + t.h : t.y + t.h - 12;
              ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.globalAlpha = 1;
          });
          
          // Draw exit portal with enhanced effect
          const exitPulse = Math.sin(this.time * 5) * 10;
          ctx.shadowColor = theme.exit;
          ctx.shadowBlur = 40 + exitPulse;
          
          // Multiple glow layers
          for (let i = 3; i >= 0; i--) {
            const size = 50 + exitPulse + i * 15;
            const portalGrad = ctx.createRadialGradient(
              this.level.exit.x + this.level.exit.w/2,
              this.level.exit.y + this.level.exit.h/2,
              0,
              this.level.exit.x + this.level.exit.w/2,
              this.level.exit.y + this.level.exit.h/2,
              size
            );
            portalGrad.addColorStop(0, theme.exit + (i === 0 ? 'ff' : '44'));
            portalGrad.addColorStop(0.5, this.adjustColor(theme.exit, -50) + '22');
            portalGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = portalGrad;
            ctx.fillRect(
              this.level.exit.x - 30 - i * 10, 
              this.level.exit.y - 30 - i * 10,
              this.level.exit.w + 60 + i * 20,
              this.level.exit.h + 60 + i * 20
            );
          }
          
          // Portal core
          ctx.fillStyle = theme.exit;
          this.roundRect(ctx, 
            this.level.exit.x - exitPulse/4, 
            this.level.exit.y - exitPulse/4,
            this.level.exit.w + exitPulse/2,
            this.level.exit.h + exitPulse/2,
            12
          );
          ctx.fill();
          
          // Portal inner detail
          ctx.fillStyle = 'rgba(255,255,255,0.5)';
          ctx.beginPath();
          ctx.arc(
            this.level.exit.x + this.level.exit.w/2,
            this.level.exit.y + this.level.exit.h/2,
            15 + Math.sin(this.time * 6) * 5,
            0,
            Math.PI * 2
          );
          ctx.fill();
          
          // Draw ghosts
          this.ghosts.forEach(g => {
            ctx.globalAlpha = g.life * 0.6;
            ctx.fillStyle = theme.player;
            ctx.shadowBlur = 15;
            ctx.shadowColor = theme.player;
            ctx.save();
            ctx.translate(g.x + this.player.w/2, g.y + this.player.h);
            ctx.scale(g.scaleX, g.scaleY);
            this.roundRect(ctx, -this.player.w/2, -this.player.h, this.player.w, this.player.h, 10);
            ctx.fill();
            ctx.restore();
          });
          ctx.globalAlpha = 1;
          
          // Draw player
          ctx.save();
          ctx.translate(this.player.x + this.player.w/2, this.player.y + this.player.h);
          ctx.rotate(this.player.rotation);
          ctx.scale(this.player.scaleX, this.player.scaleY);
          
          ctx.shadowBlur = 30;
          ctx.shadowColor = theme.player;
          
          // Body gradient
          const playerGrad = ctx.createLinearGradient(0, -this.player.h, 0, 0);
          playerGrad.addColorStop(0, theme.player);
          playerGrad.addColorStop(0.5, this.adjustColor(theme.player, 20));
          playerGrad.addColorStop(1, this.adjustColor(theme.player, -50));
          ctx.fillStyle = playerGrad;
          this.roundRect(ctx, -this.player.w/2, -this.player.h, this.player.w, this.player.h, 12);
          ctx.fill();
          
          // Shine effect
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.beginPath();
          ctx.ellipse(-5, -this.player.h * 0.75, 8, 12, -0.3, 0, Math.PI * 2);
          ctx.fill();
          
          // Eyes
          ctx.shadowBlur = 0;
          ctx.fillStyle = 'white';
          const eyeY = -this.player.h * 0.6;
          const eyeSize = 9;
          ctx.beginPath();
          ctx.arc(-9 + this.player.eyeOffset, eyeY, eyeSize, 0, Math.PI * 2);
          ctx.arc(9 + this.player.eyeOffset, eyeY, eyeSize, 0, Math.PI * 2);
          ctx.fill();
          
          // Pupils with animation
          const blinkOffset = Math.sin(this.time * 0.5) > 0.95 ? 3 : 0;
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(-6 + this.player.eyeOffset * 1.5, eyeY + blinkOffset, 5, 0, Math.PI * 2);
          ctx.arc(12 + this.player.eyeOffset * 1.5, eyeY + blinkOffset, 5, 0, Math.PI * 2);
          ctx.fill();
          
          // Eye highlights
          ctx.fillStyle = 'rgba(255,255,255,0.8)';
          ctx.beginPath();
          ctx.arc(-8 + this.player.eyeOffset, eyeY - 3, 2, 0, Math.PI * 2);
          ctx.arc(10 + this.player.eyeOffset, eyeY - 3, 2, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
        }
        
        // Draw particles
        this.particles.forEach(p => p.draw(ctx));
        
        ctx.restore();
        
        // Flash effect
        if (this.flash > 0) {
          ctx.fillStyle = this.flashColor + Math.floor(Math.min(255, this.flash * 150)).toString(16).padStart(2, '0');
          ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }
        
        // HUD
        this.drawHUD();
        
        // Screens
        if (this.state === 'START') {
          this.drawStartScreen();
        } else if (this.state === 'GAMEOVER') {
          this.drawGameOverScreen();
        }
      },
      
      drawHUD() {
        if (this.state !== 'PLAYING') return;
        
        const theme = this.level?.theme || THEMES.neonCity;
        
        ctx.save();
        ctx.scale(SCALE, SCALE);
        
        // Level indicator
        ctx.font = 'bold 16px Orbitron, sans-serif';
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(15, 15, 100, 35);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 1;
        ctx.strokeRect(15, 15, 100, 35);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.fillText(`STAGE ${this.levelId.toString().padStart(2, '0')}`, 65, 38);
        
        // Deaths counter
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(VIRTUAL_WIDTH - 85, 15, 70, 35);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.strokeRect(VIRTUAL_WIDTH - 85, 15, 70, 35);
        ctx.fillStyle = theme.trap;
        ctx.fillText(` ${this.deaths}`, VIRTUAL_WIDTH - 50, 38);
        
        // Theme name
        ctx.font = '10px Orbitron, sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillText(this.level?.theme.name || '', VIRTUAL_WIDTH / 2, 60);
        
        // Difficulty badge
        let diffText = '';
        let diffColor = '';
        if (this.levelId <= 25) {
          diffText = ' TUTORIAL';
          diffColor = '#00aaff';
        } else if (this.levelId <= 50) {
          diffText = ' EASY';
          diffColor = '#44ff44';
        } else if (this.levelId <= 80) {
          diffText = ' MEDIUM';
          diffColor = '#ffaa00';
        } else if (this.levelId <= 120) {
          diffText = ' HARD';
          diffColor = '#ff4444';
        } else {
          diffText = ' EXTREME';
          diffColor = '#ff00ff';
        }
        
        ctx.fillStyle = diffColor;
        ctx.font = 'bold 10px Orbitron, sans-serif';
        ctx.fillText(diffText, VIRTUAL_WIDTH / 2, 80);
        
        // Progress bar
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(50, 95, VIRTUAL_WIDTH - 100, 6);
        ctx.fillStyle = theme.exit;
        ctx.fillRect(50, 95, (VIRTUAL_WIDTH - 100) * (this.levelId / TOTAL_LEVELS), 6);
        
        // Combo display
        if (this.combo > 1 && this.comboTimer > 0) {
          const comboScale = 1 + Math.sin(this.time * 10) * 0.1;
          ctx.save();
          ctx.translate(VIRTUAL_WIDTH / 2, 140);
          ctx.scale(comboScale, comboScale);
          ctx.font = 'bold 24px Orbitron, sans-serif';
          ctx.fillStyle = theme.exit;
          ctx.shadowBlur = 20;
          ctx.shadowColor = theme.exit;
          ctx.fillText(` x${this.combo} COMBO!`, 0, 0);
          ctx.restore();
        }
        
        // Near miss indicator
        if (this.nearMissTimer > 0) {
          ctx.font = 'bold 14px Orbitron, sans-serif';
          ctx.fillStyle = `rgba(255,255,255,${this.nearMissTimer * 2})`;
          ctx.fillText('CLOSE CALL!', VIRTUAL_WIDTH / 2, 170);
        }
        
        ctx.restore();
      },
      
      drawStartScreen() {
        ctx.save();
        ctx.scale(SCALE, SCALE);
        
        // Background overlay
        ctx.fillStyle = 'rgba(5, 5, 16, 0.85)';
        ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);
        
        // Animated glow
        const glowRadius = 100 + Math.sin(this.time * 2) * 20;
        const glow = ctx.createRadialGradient(
          VIRTUAL_WIDTH / 2, 300, 0,
          VIRTUAL_WIDTH / 2, 300, glowRadius
        );
        glow.addColorStop(0, 'rgba(255, 45, 85, 0.4)');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);
        
        // Devil icon
        ctx.font = '80px sans-serif';
        ctx.textAlign = 'center';
        const floatY = Math.sin(this.time * 2) * 10;
        ctx.fillText('', VIRTUAL_WIDTH / 2, 280 + floatY);
        
        // Title
        ctx.font = 'bold 48px Orbitron, sans-serif';
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 30;
        ctx.shadowColor = '#ff2d55';
        ctx.fillText('LEVEL', VIRTUAL_WIDTH / 2, 380);
        ctx.fillText('DEVIL', VIRTUAL_WIDTH / 2, 440);
        
        // Subtitle
        ctx.font = '14px Orbitron, sans-serif';
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillText('COR-TECH EDITION', VIRTUAL_WIDTH / 2, 480);
        
        // Level count
        ctx.font = '12px Orbitron, sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillText(`${TOTAL_LEVELS} LEVELS  PROGRESSIVE DIFFICULTY`, VIRTUAL_WIDTH / 2, 520);
        
        // Play button
        const btnPulse = Math.sin(this.time * 4) * 0.1 + 1;
        ctx.save();
        ctx.translate(VIRTUAL_WIDTH / 2, 600);
        ctx.scale(btnPulse, btnPulse);
        
        const btnGrad = ctx.createLinearGradient(-80, -25, 80, 25);
        btnGrad.addColorStop(0, '#ff2d55');
        btnGrad.addColorStop(0.5, '#b31d3b');
        btnGrad.addColorStop(1, '#ff2d55');
        ctx.fillStyle = btnGrad;
        ctx.shadowBlur = 30;
        ctx.shadowColor = 'rgba(255, 45, 85, 0.5)';
        this.roundRect(ctx, -80, -25, 160, 50, 25);
        ctx.fill();
        
        ctx.font = 'bold 16px Orbitron, sans-serif';
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 0;
        ctx.fillText(' PLAY', 0, 6);
        ctx.restore();
        
        // Controls
        ctx.font = '10px Orbitron, sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillText('ARROWS/WASD TO MOVE  SPACE TO JUMP', VIRTUAL_WIDTH / 2, 700);
        ctx.fillText('TAP LEFT/RIGHT OR TOP TO PLAY', VIRTUAL_WIDTH / 2, 720);
        
        // High scores
        if (this.highScores.length > 0) {
          ctx.fillStyle = 'rgba(255,255,255,0.5)';
          ctx.font = '12px Orbitron, sans-serif';
          ctx.fillText(' BEST SCORES', VIRTUAL_WIDTH / 2, 780);
          
          ctx.font = '10px Orbitron, sans-serif';
          this.highScores.slice(0, 3).forEach((score, i) => {
            const medals = ['', '', ''];
            ctx.fillText(`${medals[i]} ${score.name} - ${score.deaths} deaths`, VIRTUAL_WIDTH / 2, 810 + i * 25);
          });
        }
        
        ctx.restore();
      },
      
      drawGameOverScreen() {
        ctx.save();
        ctx.scale(SCALE, SCALE);
        
        // Background overlay
        ctx.fillStyle = 'rgba(5, 5, 16, 0.9)';
        ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);
        
        // Victory glow
        const glowRadius = 120 + Math.sin(this.time * 2) * 30;
        const glow = ctx.createRadialGradient(
          VIRTUAL_WIDTH / 2, 280, 0,
          VIRTUAL_WIDTH / 2, 280, glowRadius
        );
        glow.addColorStop(0, 'rgba(255, 215, 0, 0.5)');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);
        
        // Trophy
        ctx.font = '100px sans-serif';
        ctx.textAlign = 'center';
        const floatY = Math.sin(this.time * 2) * 8;
        ctx.fillText('', VIRTUAL_WIDTH / 2, 280 + floatY);
        
        // Title
        ctx.font = 'bold 42px Orbitron, sans-serif';
        ctx.fillStyle = '#ffd700';
        ctx.shadowBlur = 30;
        ctx.shadowColor = '#ffd700';
        ctx.fillText('VICTORY!', VIRTUAL_WIDTH / 2, 380);
        
        // Subtitle
        ctx.font = '14px Orbitron, sans-serif';
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fillText(`ALL ${TOTAL_LEVELS} LEVELS CLEARED`, VIRTUAL_WIDTH / 2, 420);
        
        // Stats
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(80, 460, 160, 80);
        ctx.fillRect(VIRTUAL_WIDTH - 240, 460, 160, 80);
        
        ctx.fillStyle = '#00f2ff';
        ctx.font = 'bold 32px Orbitron, sans-serif';
        ctx.fillText(this.deaths.toString(), 160, 510);
        ctx.fillText(this.formatTime(this.totalTime), VIRTUAL_WIDTH - 160, 510);
        
        ctx.font = '10px Orbitron, sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillText('TOTAL DEATHS', 160, 530);
        ctx.fillText('TIME', VIRTUAL_WIDTH - 160, 530);
        
        // Restart button
        const btnPulse = Math.sin(this.time * 4) * 0.05 + 1;
        ctx.save();
        ctx.translate(VIRTUAL_WIDTH / 2, 620);
        ctx.scale(btnPulse, btnPulse);
        
        ctx.fillStyle = '#00f2ff';
        ctx.shadowBlur = 20;
        ctx.shadowColor = 'rgba(0, 242, 255, 0.5)';
        this.roundRect(ctx, -80, -25, 160, 50, 25);
        ctx.fill();
        
        ctx.font = 'bold 14px Orbitron, sans-serif';
        ctx.fillStyle = '#000';
        ctx.shadowBlur = 0;
        ctx.fillText(' RESTART', 0, 5);
        ctx.restore();
        
        // Press R hint
        ctx.font = '10px Orbitron, sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillText('PRESS R OR TAP TO RESTART', VIRTUAL_WIDTH / 2, 700);
        
        ctx.restore();
      },
      
      formatTime(seconds: number) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      },
      
      roundRect(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number, r: number) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
      },
      
      adjustColor(hex: string, amount: number) {
        const num = parseInt(hex.replace('#', ''), 16);
        const r = Math.max(0, Math.min(255, (num >> 16) + amount));
        const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
        const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
        return '#' + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1);
      },
      
      loop() {
        const now = performance.now();
        const dt = Math.min((now - (this.lastFrame || now)) / 1000, 0.05);
        this.lastFrame = now;
        
        this.update(dt);
        this.draw();
        
        requestAnimationFrame(() => this.loop());
      },
      
      startDemo() {
        this.demoMode = true;
        this.state = 'PLAYING';
        this.levelId = 1;
        this.resetLevel();
      },
      
      stopDemo() {
        this.demoMode = false;
        this.state = 'START';
        this.resetLevel();
      },
      
      updateAI() {
        if (!this.level) return;
        
        const targetX = this.level.exit.x;
        const targetY = this.level.exit.y;
        
        if (this.player.x < targetX - 30) {
          this.input.right = true;
          this.input.left = false;
        } else if (this.player.x > targetX + 30) {
          this.input.left = true;
          this.input.right = false;
        } else {
          this.input.left = this.input.right = false;
        }
        
        if (this.player.grounded && (this.player.y > targetY + 60 || Math.random() < 0.03)) {
          this.input.up = true;
          setTimeout(() => this.input.up = false, 80);
        }
        
        if (Math.random() < 0.008) {
          this.input.up = true;
          setTimeout(() => this.input.up = false, 80);
        }
      },
      
      loadScores() {
        try {
          this.highScores = JSON.parse(localStorage.getItem('levelDevilScores') || '[]');
        } catch {
          this.highScores = [];
        }
      },
      
      saveScore() {
        const name = 'PLAYER';
        this.highScores.push({ name, deaths: this.deaths });
        this.highScores.sort((a, b) => a.deaths - b.deaths);
        this.highScores = this.highScores.slice(0, 5);
        try {
          localStorage.setItem('levelDevilScores', JSON.stringify(this.highScores));
        } catch {}
      },
      
      reset() {
        this.state = 'START';
        this.saveScore();
      }
    };
    
    gameRef.current = game;
    game.init();
  }, []);
  
  useEffect(() => {
    initGame();
    
    return () => {
      // Cleanup if needed
    };
  }, [initGame]);
  
  return (
    <div className="w-screen h-screen bg-[#050510] flex items-center justify-center overflow-hidden">
      <canvas
        ref={canvasRef}
        id="gameCanvas"
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        className="max-w-full max-h-full shadow-[0_0_100px_rgba(0,242,255,0.15)] rounded-lg"
        style={{ aspectRatio: '9/16' }}
      />
    </div>
  );
}
